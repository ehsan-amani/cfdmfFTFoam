/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  9.0                                   |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     9.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     interFoam; 

startTime       latestTime;

stopAt          endTime;

endTime         3.0; //1st

deltaT          1.0e-7;

//writeControl    timeStep;
writeControl    adjustableRunTime;

writeInterval   0.02;

purgeWrite      0;

writeFormat     ascii;

writePrecision  7;

writeCompression yes;

timeFormat      general;

timePrecision   6;

runTimeModifiable no;

adjustTimeStep  yes;

maxCo           0.1;
maxAlphaCo      0.1;

maxDeltaT       1e-04;
dimensionSet    0;

/*
libs (
    "libOpenFOAM.so" // keeps paraFoam happy
    "libsimpleSwakFunctionObjects.so"
    "libsimpleFunctionObjects.so" 
   );

functions
{
barycenter
    {
        type swakExpression;
        valueType internalField;
        verbose true;
		variables (
		"Vol= sum ((1-ALPHA) * vol());"
		"VolY= sum ((1-ALPHA) * pos().y*vol());"	
	);        
	expression "VolY/Vol";
        accumulations (
		min		
        );
        aliases {
            ALPHA alpha.water; //a workaround for the dot in field name
        }
        outputControlMode timeStep;
        outputInterval 10;        
    }
    
    
riseVelocity
    {
        type swakExpression;
        valueType internalField;
        verbose true;
		variables (
		"Vol= sum ((1-ALPHA) * vol());"
		"VolVZ= sum ((1-ALPHA) * vel.z*vol());"	
	);        
	expression "VolVZ/Vol";
        accumulations (
		min		
        );
        aliases {
            ALPHA alpha.water; //a workaround for the dot in field name
            vel U;
        }
        outputControlMode timeStep;
        outputInterval 10;         
    } 

sphericity
    {
        type swakExpression;
        valueType internalField;
        verbose true;
		variables (
		"Vol= sum ((1-ALPHA) * vol());"
		"Area= sum(mag(grad(ALPHA))* vol());"	
	);        
	expression "pow(pi,1./3)* pow(6*Vol,2./3) / Area";
        accumulations (
		min		
        );
        aliases {
            ALPHA alpha.water; //a workaround for the dot in field name
        }
        outputControlMode timeStep;
        outputInterval 10;         
    } 

}
*/
// ************************************************************************* //
/*
// functionObjects
functions
{
    // **************************************************** //
    // **** coded functionObject for bubble processing **** //
    // **************************************************** //
    bubblepproc
    {
        // Load the library containing the 'coded' functionObject
        libs (utilityFunctionObjects);
        type coded;
        writeControl    adjustableRunTime;
        writeInterval   0.02;
        // Name of on-the-fly generated functionObject
        name bubblepproc;
        // List of include search directories
        codeOptions
        #{
            -I$(LIB_SRC)/sampling/lnInclude \
            -I$(LIB_SRC)/dynamicMesh/lnInclude \
            -I$(LIB_SRC)/surfMesh/lnInclude
        #};
        // List of libraries to link with
        codeLibs
        #{
            -lsampling \
            -ldynamicMesh \
            -lsurfMesh
        #};
        // List of include files
        codeInclude
        #{
            #include "sampledIsoSurface.H"
            #include "vtkSurfaceWriter.H"
        #};
        // Code
        codeWrite
        #{
            Info << "----------bubblepproc----------" << endl;

            // Lookup velocity field U
            const volVectorField& U = mesh().lookupObject<volVectorField>("U");

            // Lookup liquid fraction alpha_liquid
            const volScalarField& alphaLiquid = mesh().lookupObject<volScalarField>("alpha.phase1");

            // Compute weight (= gas fraction)
            volScalarField weight
            (
                IOobject
                (
                    "weight",
                    mesh().time().timeName(),
                    U.mesh(),
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                (1-alphaLiquid)
            );

            // Compute isosurface alpha=0.5
            dictionary isoSurfDict;
            isoSurfDict.add("type","isoSurface");
            isoSurfDict.add("isoField","alpha.phase1");
            isoSurfDict.add("isoValue",0.5);
            isoSurfDict.add("regularise","diagcell");
            isoSurfDict.add("snap","off");
            sampledIsoSurface isoInterface("isoInterface", mesh(), isoSurfDict);
            isoInterface.update();

            // Debug output of isosurface in vtk format
            if ( mesh().time().writeTime() && false )
            {
              // Create output file name and directory
              const fileName outputPath(mesh().time().globalPath()/functionObject::outputPrefix/"bubblepproc_DEBUG"/mesh().time().timeName());
              mkDir(outputPath);
              const fileName outputName(outputPath/isoInterface.name());
              Info << "Writing debug surface: " << outputName << nl;
              // Write file in vtk format
              bool parallel = Pstream::parRun();
              dictionary vtkWriterOptions;
              vtkWriterOptions.add("format","ascii");
              surfaceWriters::vtkWriter writerDebug(isoInterface,outputName,parallel,vtkWriterOptions);
              writerDebug.write();
            }

            // Compute bubble volume
            dimensionedScalar bubbleVolume = fvc::domainIntegrate(weight); // This is integral of "weight" over the volume
            Info << "bubble volume     = " << bubbleVolume.value() << endl;

            // Compute bubble area
            dimensionedScalar bubbleArea = isoInterface.area();
            Info << "bubble area       = " << bubbleArea.value() << endl;

            // Compute bubble center
            dimensionedVector Cb = fvc::domainIntegrate(weight*mesh().C())/bubbleVolume;
            Info << "bubble centroid   = " << Cb.value() << endl;

            // Compute rising velocity
            dimensionedVector Ub = fvc::domainIntegrate(weight*U)/bubbleVolume;
            Info << "bubble velocity   = " << Ub.value() << endl;

            // Compute radius of volume equivalent sphere (from bubble volume)
            dimensionedScalar radiusA = pow(3.0/4.0/constant::mathematical::pi*bubbleVolume, 1.0/3.0);
            Info << "bubble diameter A = " << radiusA.value()*2.0 << endl;

            // Compute radius of bubble (from bubble surface)
            dimensionedScalar radiusB = sqrt(bubbleArea/constant::mathematical::pi/4.0);
            Info << "bubble diameter B = " << radiusB.value()*2.0 << endl;

            // Compute degree of sphericity
            if ( radiusB.value() != 0.0 )
            Info << "bubble sphericity = " << pow(radiusA.value()/radiusB.value(),2) << endl;

            Info << "----------bubblepproc----------\n" << endl;

        #};
    }

    // ********************************************************** //
    // **** sample functionObject for extracting isosurfaces **** //
    // ********************************************************** //
    isosurfaces
    {
        type            surfaces;
        libs            (sampling);
        writeControl    adjustableRunTime;
        writeInterval   0.02;

        surfaceFormat   vtk;
        fields          ( p U );

        // interpolationScheme. choice of
        //      cell          : use cell-centre value only; constant over cells (default)
        //      cellPoint     : use cell-centre and vertex values
        //      cellPointFace : use cell-centre, vertex and face values.
        //      pointMVC      : use point values only (Mean Value Coordinates)
        //      cellPatchConstrained : like 'cell' but uses cell-centre except on
        //                             boundary faces where it uses the boundary value.
        //      cellPointWallModified: like 'cell' but uses cell-centre except on
        //                             walls faces where it uses the wall value.
        interpolationScheme cellPointFace;

        // Surface sampling definition
        //
        // 1] patches are not triangulated by default
        // 2] planes are always triangulated
        // 3] iso-surfaces are always triangulated
        surfaces
        (
          constantIso
          {
              // Iso surface for constant values.
              // Triangles guaranteed not to cross cells.
              type            isoSurface;
              isoField        alpha.phase1;
              isoValue        0.5;
              interpolate     false;
              regularise      true;
          }
        );
    }
}
*/

functions
{
    bubbleDiagnostics
    {
        type            coded;
        libs            ("libutilityFunctionObjects.so");
        writeControl    outputTime; //timeStep;
        //writeInterval   20;
        executeControl  outputTime; //timeStep;
        //executeInterval 20;
		enabled         yes;

        codeExecute
        #{
            const volScalarField& alpha = mesh().lookupObject<volScalarField>("alpha.water");
            const volVectorField& U     = mesh().lookupObject<volVectorField>("U");
			const scalarField& vCell = mesh().V();

            scalarField gasPhase(1.0 - alpha.internalField());
			scalar volume = gSum(gasPhase* vCell);

            scalar velZ = gSum(gasPhase * U.internalField().component(vector::Z) * vCell)
                        /(volume + VSMALL);

			const vectorField& gradAlpha = fvc::grad(alpha).ref().internalField();
            scalar surface = gSum(mag(gradAlpha) * vCell);

            scalar sphericity = pow(constant::mathematical::pi,1./3)
						*pow(6*volume, 2./3)/( surface + VSMALL);

            scalar t = mesh().time().value();

         	// Append to file (master processor only)
			if (Pstream::master())
            {
                fileName outputPath("bubbleDiagnostics.dat");
                OFstream file
                (
                    outputPath,
                    IOstream::ASCII,
                    IOstream::currentVersion,
                    IOstream::UNCOMPRESSED,
                    true
                );
                file << t << '\t' << velZ << '\t' << sphericity << endl;
            }

            //Info<< "Time = " << t << ": VelZ = " << velZ << " | Sphericity = " << sphericity << endl;
        #};
    }

}
// ************************************************************************* //

