/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  9.0                                   |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     9.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     cfdmfFTFoam;

startTime       latestTime;

stopAt          endTime;

endTime         0.30854; //1st

deltaT          1.0e-7; //1.0e-3;

//writeControl    timeStep;
writeControl    adjustableRunTime;

writeInterval   0.00514;

purgeWrite      0;

writeFormat     ascii;

writePrecision  7;

writeCompression yes;

timeFormat      general;

timePrecision   6;

runTimeModifiable no;

adjustTimeStep  yes;

maxCo           0.1;
maxAlphaCo      0.1;

maxDeltaT       1.e-4;
dimensionSet    0;

/*
libs (
    "libOpenFOAM.so" // keeps paraFoam happy
    "libsimpleSwakFunctionObjects.so"
    "libsimpleFunctionObjects.so" 
   );

functions
{
barycenter
    {
        type swakExpression;
        valueType internalField;
        verbose true;
	variables (
	"Vol= sum ((1-ALPHA) * vol());"
	"VolY= sum ((1-ALPHA) * pos().y*vol());"	
	);        
	expression "VolY/Vol";
        accumulations (
		min		
        );
        aliases {
            ALPHA Indicator_; //a workaround for the dot in field name
        }
        outputControlMode timeStep;
        outputInterval 10;        
    }
    
    
riseVelocity
    {
        type swakExpression;
        valueType internalField;
        verbose true;
	variables (
	"Vol= sum ((1-ALPHA) * vol());"
	"VolVZ= sum ((1-ALPHA) * vel.z*vol());"	
	);        
	expression "VolVZ/Vol";
        accumulations (
		min		
        );
        aliases {
            ALPHA Indicator_; //a workaround for the dot in field name
            vel U;
        }
        outputControlMode timeStep;
        outputInterval 10;         
    } 

sphericity
    {
        type swakExpression;
        valueType internalField;
        verbose true;
	variables (
	"Vol= sum ((1-ALPHA) * vol());"
	"Area= sum(mag(grad(ALPHA))* vol());"	
	);        
	expression "pow(pi,1./3)* pow(6*Vol,2./3) / Area";
        accumulations (
		min		
        );
        aliases {
            ALPHA Indicator_; //a workaround for the dot in field name
        }
        outputControlMode timeStep;
        outputInterval 10;         
    } 

}*/

functions
{
    bubbleRiseVelocity
    {
        type            coded;
        libs            ("libutilityFunctionObjects.so");
        writeControl    outputTime; //timeStep;
        //writeInterval   20;
        executeControl  outputTime; //timeStep;
        //executeInterval 20;
		enabled         yes;
/*
		code
        #{
            // Initialization - create empty file with header
            if (Pstream::master())  // Only master processor creates file
            {
                fileName outputPath("bubbleRiseVelocity.dat");
                OFstream riseFile(outputPath);
                riseFile << "# Time (s)\tVelocityZ (m/s)" << endl;
            }
        #};
*/
        codeExecute
        #{
            const volScalarField& alpha = mesh().lookupObject<volScalarField>("indicator");
            const volVectorField& U     = mesh().lookupObject<volVectorField>("U");
			const scalarField& vCell = mesh().V();

			// Calculate bubble velocity
            scalarField gasPhase(1.0 - alpha.internalField());
            scalar velZ = gSum(gasPhase * U.internalField().component(vector::Z) * vCell)
                        /(gSum(gasPhase * vCell) + VSMALL);
            scalar t = mesh().time().value();

         	// Append to file (master processor only)
            if (Pstream::master())
            {
                fileName outputPath("bubbleRiseVelocity.dat");
				OFstream riseFile
				(
					outputPath,
					IOstream::ASCII,           // format
					IOstream::currentVersion,  // version (note lowercase)
					IOstream::UNCOMPRESSED,    // compression
					true                       // append mode
				);

                riseFile << t << '\t' << velZ << endl;
            }

            //Info<< "Bubble rise velocity: " << velZ << " m/s" << endl;
        #};
    }
}
